{"ast":null,"code":"import _extends from \"@babel/runtime/helpers/extends\";\n\nvar decasteljau = function () {\n  var _f = function _f(points, t) {\n    var left = [];\n    var right = [];\n\n    var decasteljauRecurse = function () {\n      var _f = function _f(points, t) {\n        if (points.length === 1) {\n          left.push(points[0]);\n          right.push(points[0]);\n        } else {\n          var newPoints = Array(points.length - 1);\n\n          for (var i = 0; i < newPoints.length; i++) {\n            if (i === 0) {\n              left.push(points[0]);\n            }\n\n            if (i === newPoints.length - 1) {\n              right.push(points[i + 1]);\n            }\n\n            newPoints[i] = [(1 - t) * points[i][0] + t * points[i + 1][0], (1 - t) * points[i][1] + t * points[i + 1][1]];\n          }\n\n          decasteljauRecurse(newPoints, t);\n        }\n      };\n\n      _f._closure = {\n        left: left,\n        right: right\n      };\n      _f.asString = \"function decasteljauRecurse(points,t){const{left,right}=jsThis._closure;{if(points.length===1){left.push(points[0]);right.push(points[0]);}else{const newPoints=Array(points.length-1);for(let i=0;i<newPoints.length;i++){if(i===0){left.push(points[0]);}if(i===newPoints.length-1){right.push(points[i+1]);}newPoints[i]=[(1-t)*points[i][0]+t*points[i+1][0],(1-t)*points[i][1]+t*points[i+1][1]];}decasteljauRecurse(newPoints,t);}}}\";\n      _f.__workletHash = 13659663177248;\n      _f.__location = \"D:\\\\Personal\\\\00 Dossair\\\\CryptoTrackerFinal\\\\node_modules\\\\react-native-wagmi-charts\\\\lib\\\\module\\\\charts\\\\line\\\\utils\\\\interpolatePath.js (24:2)\";\n\n      global.__reanimatedWorkletInit(_f);\n\n      return _f;\n    }();\n\n    if (points.length) {\n      decasteljauRecurse(points, t);\n    }\n\n    return {\n      left: left,\n      right: right.reverse()\n    };\n  };\n\n  _f._closure = {};\n  _f.asString = \"function decasteljau(points,t){const left=[];const right=[];function decasteljauRecurse(points,t){'worklet';if(points.length===1){left.push(points[0]);right.push(points[0]);}else{const newPoints=Array(points.length-1);for(let i=0;i<newPoints.length;i++){if(i===0){left.push(points[0]);}if(i===newPoints.length-1){right.push(points[i+1]);}newPoints[i]=[(1-t)*points[i][0]+t*points[i+1][0],(1-t)*points[i][1]+t*points[i+1][1]];}decasteljauRecurse(newPoints,t);}}if(points.length){decasteljauRecurse(points,t);}return{left:left,right:right.reverse()};}\";\n  _f.__workletHash = 9830344733692;\n  _f.__location = \"D:\\\\Personal\\\\00 Dossair\\\\CryptoTrackerFinal\\\\node_modules\\\\react-native-wagmi-charts\\\\lib\\\\module\\\\charts\\\\line\\\\utils\\\\interpolatePath.js (18:0)\";\n\n  global.__reanimatedWorkletInit(_f);\n\n  return _f;\n}();\n\nvar pointsToCommand = function () {\n  var _f = function _f(points) {\n    var command = {};\n\n    if (points.length === 4) {\n      command.x2 = points[2][0];\n      command.y2 = points[2][1];\n    }\n\n    if (points.length >= 3) {\n      command.x1 = points[1][0];\n      command.y1 = points[1][1];\n    }\n\n    command.x = points[points.length - 1][0];\n    command.y = points[points.length - 1][1];\n\n    if (points.length === 4) {\n      command.type = 'C';\n    } else if (points.length === 3) {\n      command.type = 'Q';\n    } else {\n      command.type = 'L';\n    }\n\n    return command;\n  };\n\n  _f._closure = {};\n  _f.asString = \"function pointsToCommand(points){const command={};if(points.length===4){command.x2=points[2][0];command.y2=points[2][1];}if(points.length>=3){command.x1=points[1][0];command.y1=points[1][1];}command.x=points[points.length-1][0];command.y=points[points.length-1][1];if(points.length===4){command.type='C';}else if(points.length===3){command.type='Q';}else{command.type='L';}return command;}\";\n  _f.__workletHash = 11528182296603;\n  _f.__location = \"D:\\\\Personal\\\\00 Dossair\\\\CryptoTrackerFinal\\\\node_modules\\\\react-native-wagmi-charts\\\\lib\\\\module\\\\charts\\\\line\\\\utils\\\\interpolatePath.js (67:0)\";\n\n  global.__reanimatedWorkletInit(_f);\n\n  return _f;\n}();\n\nvar splitCurveAsPoints = function () {\n  var _f = function _f(points, segmentCount) {\n    segmentCount = segmentCount || 2;\n    var segments = [];\n    var remainingCurve = points;\n    var tIncrement = 1 / segmentCount;\n\n    for (var i = 0; i < segmentCount - 1; i++) {\n      var tRelative = tIncrement / (1 - tIncrement * i);\n      var split = decasteljau(remainingCurve, tRelative);\n      segments.push(split.left);\n      remainingCurve = split.right;\n    }\n\n    segments.push(remainingCurve);\n    return segments;\n  };\n\n  _f._closure = {\n    decasteljau: decasteljau\n  };\n  _f.asString = \"function splitCurveAsPoints(points,segmentCount){const{decasteljau}=jsThis._closure;{segmentCount=segmentCount||2;const segments=[];let remainingCurve=points;const tIncrement=1/segmentCount;for(let i=0;i<segmentCount-1;i++){const tRelative=tIncrement/(1-tIncrement*i);const split=decasteljau(remainingCurve,tRelative);segments.push(split.left);remainingCurve=split.right;}segments.push(remainingCurve);return segments;}}\";\n  _f.__workletHash = 1833073153407;\n  _f.__location = \"D:\\\\Personal\\\\00 Dossair\\\\CryptoTrackerFinal\\\\node_modules\\\\react-native-wagmi-charts\\\\lib\\\\module\\\\charts\\\\line\\\\utils\\\\interpolatePath.js (107:0)\";\n\n  global.__reanimatedWorkletInit(_f);\n\n  return _f;\n}();\n\nexport var splitCurve = function () {\n  var _f = function _f(commandStart, commandEnd, segmentCount) {\n    var points = [[commandStart.x, commandStart.y]];\n\n    if (commandEnd.x1 != null) {\n      points.push([commandEnd.x1, commandEnd.y1]);\n    }\n\n    if (commandEnd.x2 != null) {\n      points.push([commandEnd.x2, commandEnd.y2]);\n    }\n\n    points.push([commandEnd.x, commandEnd.y]);\n    return splitCurveAsPoints(points, segmentCount).map(pointsToCommand);\n  };\n\n  _f._closure = {\n    splitCurveAsPoints: splitCurveAsPoints,\n    pointsToCommand: pointsToCommand\n  };\n  _f.asString = \"function splitCurve(commandStart,commandEnd,segmentCount){const{splitCurveAsPoints,pointsToCommand}=jsThis._closure;{const points=[[commandStart.x,commandStart.y]];if(commandEnd.x1!=null){points.push([commandEnd.x1,commandEnd.y1]);}if(commandEnd.x2!=null){points.push([commandEnd.x2,commandEnd.y2]);}points.push([commandEnd.x,commandEnd.y]);return splitCurveAsPoints(points,segmentCount).map(pointsToCommand);}}\";\n  _f.__workletHash = 12286232578436;\n  _f.__location = \"D:\\\\Personal\\\\00 Dossair\\\\CryptoTrackerFinal\\\\node_modules\\\\react-native-wagmi-charts\\\\lib\\\\module\\\\charts\\\\line\\\\utils\\\\interpolatePath.js (150:7)\";\n\n  global.__reanimatedWorkletInit(_f);\n\n  return _f;\n}();\nvar typeMap = {\n  M: ['x', 'y'],\n  L: ['x', 'y'],\n  H: ['x'],\n  V: ['y'],\n  C: ['x1', 'y1', 'x2', 'y2', 'x', 'y'],\n  S: ['x2', 'y2', 'x', 'y'],\n  Q: ['x1', 'y1', 'x', 'y'],\n  T: ['x', 'y'],\n  A: ['rx', 'ry', 'xAxisRotation', 'largeArcFlag', 'sweepFlag', 'x', 'y'],\n  Z: []\n};\nObject.keys(typeMap).forEach(function (key) {\n  typeMap[key.toLowerCase()] = typeMap[key];\n});\n\nvar arrayOfLength = function () {\n  var _f = function _f(length, value) {\n    var array = Array(length);\n\n    for (var i = 0; i < length; i++) {\n      array[i] = value;\n    }\n\n    return array;\n  };\n\n  _f._closure = {};\n  _f.asString = \"function arrayOfLength(length,value){const array=Array(length);for(let i=0;i<length;i++){array[i]=value;}return array;}\";\n  _f.__workletHash = 9541794002397;\n  _f.__location = \"D:\\\\Personal\\\\00 Dossair\\\\CryptoTrackerFinal\\\\node_modules\\\\react-native-wagmi-charts\\\\lib\\\\module\\\\charts\\\\line\\\\utils\\\\interpolatePath.js (187:0)\";\n\n  global.__reanimatedWorkletInit(_f);\n\n  return _f;\n}();\n\nvar commandToString = function () {\n  var _f = function _f(command) {\n    return \"\" + command.type + typeMap[command.type].map(function (p) {\n      return command[p];\n    }).join(',');\n  };\n\n  _f._closure = {\n    typeMap: typeMap\n  };\n  _f.asString = \"function commandToString(command){const{typeMap}=jsThis._closure;{return\\\"\\\"+command.type+typeMap[command.type].map(function(p){return command[p];}).join(',');}}\";\n  _f.__workletHash = 6965297412736;\n  _f.__location = \"D:\\\\Personal\\\\00 Dossair\\\\CryptoTrackerFinal\\\\node_modules\\\\react-native-wagmi-charts\\\\lib\\\\module\\\\charts\\\\line\\\\utils\\\\interpolatePath.js (205:0)\";\n\n  global.__reanimatedWorkletInit(_f);\n\n  return _f;\n}();\n\nvar convertToSameType = function () {\n  var _f = function _f(aCommand, bCommand) {\n    var conversionMap = {\n      x1: 'x',\n      y1: 'y',\n      x2: 'x',\n      y2: 'y'\n    };\n    var readFromBKeys = ['xAxisRotation', 'largeArcFlag', 'sweepFlag'];\n\n    if (aCommand.type !== bCommand.type && bCommand.type.toUpperCase() !== 'M') {\n      var aConverted = {};\n      Object.keys(bCommand).forEach(function (bKey) {\n        var bValue = bCommand[bKey];\n        var aValue = aCommand[bKey];\n\n        if (aValue === undefined) {\n          if (readFromBKeys.includes(bKey)) {\n            aValue = bValue;\n          } else {\n            if (aValue === undefined && conversionMap[bKey]) {\n              aValue = aCommand[conversionMap[bKey]];\n            }\n\n            if (aValue === undefined) {\n              aValue = 0;\n            }\n          }\n        }\n\n        aConverted[bKey] = aValue;\n      });\n      aConverted.type = bCommand.type;\n      aCommand = aConverted;\n    }\n\n    return aCommand;\n  };\n\n  _f._closure = {};\n  _f.asString = \"function convertToSameType(aCommand,bCommand){const conversionMap={x1:'x',y1:'y',x2:'x',y2:'y'};const readFromBKeys=['xAxisRotation','largeArcFlag','sweepFlag'];if(aCommand.type!==bCommand.type&&bCommand.type.toUpperCase()!=='M'){const aConverted={};Object.keys(bCommand).forEach(function(bKey){const bValue=bCommand[bKey];let aValue=aCommand[bKey];if(aValue===undefined){if(readFromBKeys.includes(bKey)){aValue=bValue;}else{if(aValue===undefined&&conversionMap[bKey]){aValue=aCommand[conversionMap[bKey]];}if(aValue===undefined){aValue=0;}}}aConverted[bKey]=aValue;});aConverted.type=bCommand.type;aCommand=aConverted;}return aCommand;}\";\n  _f.__workletHash = 6410879760195;\n  _f.__location = \"D:\\\\Personal\\\\00 Dossair\\\\CryptoTrackerFinal\\\\node_modules\\\\react-native-wagmi-charts\\\\lib\\\\module\\\\charts\\\\line\\\\utils\\\\interpolatePath.js (232:0)\";\n\n  global.__reanimatedWorkletInit(_f);\n\n  return _f;\n}();\n\nvar splitSegment = function () {\n  var _f = function _f(commandStart, commandEnd, segmentCount) {\n    var segments = [];\n\n    if (commandEnd.type === 'L' || commandEnd.type === 'Q' || commandEnd.type === 'C') {\n      segments = segments.concat(splitCurve(commandStart, commandEnd, segmentCount));\n    } else {\n      var copyCommand = _extends({}, commandStart);\n\n      if (copyCommand.type === 'M') {\n        copyCommand.type = 'L';\n      }\n\n      segments = segments.concat(arrayOfLength(segmentCount - 1).map(function () {\n        return copyCommand;\n      }));\n      segments.push(commandEnd);\n    }\n\n    return segments;\n  };\n\n  _f._closure = {\n    splitCurve: splitCurve,\n    arrayOfLength: arrayOfLength\n  };\n  _f.asString = \"function splitSegment(commandStart,commandEnd,segmentCount){const{splitCurve,arrayOfLength}=jsThis._closure;{let segments=[];if(commandEnd.type==='L'||commandEnd.type==='Q'||commandEnd.type==='C'){segments=segments.concat(splitCurve(commandStart,commandEnd,segmentCount));}else{const copyCommand=Object.assign({},commandStart);if(copyCommand.type==='M'){copyCommand.type='L';}segments=segments.concat(arrayOfLength(segmentCount-1).map(function(){return copyCommand;}));segments.push(commandEnd);}return segments;}}\";\n  _f.__workletHash = 6799202132813;\n  _f.__location = \"D:\\\\Personal\\\\00 Dossair\\\\CryptoTrackerFinal\\\\node_modules\\\\react-native-wagmi-charts\\\\lib\\\\module\\\\charts\\\\line\\\\utils\\\\interpolatePath.js (289:0)\";\n\n  global.__reanimatedWorkletInit(_f);\n\n  return _f;\n}();\n\nvar extend = function () {\n  var _f = function _f(commandsToExtend, referenceCommands, excludeSegment) {\n    var numSegmentsToExtend = commandsToExtend.length - 1;\n    var numReferenceSegments = referenceCommands.length - 1;\n    var segmentRatio = numSegmentsToExtend / numReferenceSegments;\n    var countPointsPerSegment = arrayOfLength(numReferenceSegments).reduce(function (accum, d, i) {\n      var insertIndex = Math.floor(segmentRatio * i);\n\n      if (excludeSegment && insertIndex < commandsToExtend.length - 1 && excludeSegment(commandsToExtend[insertIndex], commandsToExtend[insertIndex + 1])) {\n        var addToPriorSegment = segmentRatio * i % 1 < 0.5;\n\n        if (accum[insertIndex]) {\n          if (addToPriorSegment) {\n            if (insertIndex > 0) {\n              insertIndex -= 1;\n            } else if (insertIndex < commandsToExtend.length - 1) {\n              insertIndex += 1;\n            }\n          } else if (insertIndex < commandsToExtend.length - 1) {\n            insertIndex += 1;\n          } else if (insertIndex > 0) {\n            insertIndex -= 1;\n          }\n        }\n      }\n\n      accum[insertIndex] = (accum[insertIndex] || 0) + 1;\n      return accum;\n    }, []);\n    var extended = countPointsPerSegment.reduce(function (extended, segmentCount, i) {\n      if (i === commandsToExtend.length - 1) {\n        var lastCommandCopies = arrayOfLength(segmentCount, _extends({}, commandsToExtend[commandsToExtend.length - 1]));\n\n        if (lastCommandCopies[0].type === 'M') {\n          lastCommandCopies.forEach(function (d) {\n            d.type = 'L';\n          });\n        }\n\n        return extended.concat(lastCommandCopies);\n      }\n\n      return extended.concat(splitSegment(commandsToExtend[i], commandsToExtend[i + 1], segmentCount));\n    }, []);\n    extended.unshift(commandsToExtend[0]);\n    return extended;\n  };\n\n  _f._closure = {\n    arrayOfLength: arrayOfLength,\n    splitSegment: splitSegment\n  };\n  _f.asString = \"function extend(commandsToExtend,referenceCommands,excludeSegment){const{arrayOfLength,splitSegment}=jsThis._closure;{const numSegmentsToExtend=commandsToExtend.length-1;const numReferenceSegments=referenceCommands.length-1;const segmentRatio=numSegmentsToExtend/numReferenceSegments;const countPointsPerSegment=arrayOfLength(numReferenceSegments).reduce(function(accum,d,i){let insertIndex=Math.floor(segmentRatio*i);if(excludeSegment&&insertIndex<commandsToExtend.length-1&&excludeSegment(commandsToExtend[insertIndex],commandsToExtend[insertIndex+1])){const addToPriorSegment=segmentRatio*i%1<0.5;if(accum[insertIndex]){if(addToPriorSegment){if(insertIndex>0){insertIndex-=1;}else if(insertIndex<commandsToExtend.length-1){insertIndex+=1;}}else if(insertIndex<commandsToExtend.length-1){insertIndex+=1;}else if(insertIndex>0){insertIndex-=1;}}}accum[insertIndex]=(accum[insertIndex]||0)+1;return accum;},[]);const extended=countPointsPerSegment.reduce(function(extended,segmentCount,i){if(i===commandsToExtend.length-1){const lastCommandCopies=arrayOfLength(segmentCount,Object.assign({},commandsToExtend[commandsToExtend.length-1]));if(lastCommandCopies[0].type==='M'){lastCommandCopies.forEach(function(d){d.type='L';});}return extended.concat(lastCommandCopies);}return extended.concat(splitSegment(commandsToExtend[i],commandsToExtend[i+1],segmentCount));},[]);extended.unshift(commandsToExtend[0]);return extended;}}\";\n  _f.__workletHash = 7949237301601;\n  _f.__location = \"D:\\\\Personal\\\\00 Dossair\\\\CryptoTrackerFinal\\\\node_modules\\\\react-native-wagmi-charts\\\\lib\\\\module\\\\charts\\\\line\\\\utils\\\\interpolatePath.js (322:0)\";\n\n  global.__reanimatedWorkletInit(_f);\n\n  return _f;\n}();\n\nexport var pathCommandsFromString = function () {\n  var _f = function _f(d) {\n    var tokens = (d || '').match(/[MLCSTQAHVZmlcstqahv]|-?[\\d.e+-]+/g) || [];\n    var commands = [];\n    var commandArgs;\n    var command;\n\n    for (var i = 0; i < tokens.length; ++i) {\n      commandArgs = typeMap[tokens[i]];\n\n      if (commandArgs) {\n        command = {\n          type: tokens[i]\n        };\n\n        for (var a = 0; a < commandArgs.length; ++a) {\n          command[commandArgs[a]] = +tokens[i + a + 1];\n        }\n\n        i += commandArgs.length;\n        commands.push(command);\n      }\n    }\n\n    return commands;\n  };\n\n  _f._closure = {\n    typeMap: typeMap\n  };\n  _f.asString = \"function pathCommandsFromString(d){const{typeMap}=jsThis._closure;{const tokens=(d||'').match(/[MLCSTQAHVZmlcstqahv]|-?[\\\\d.e+-]+/g)||[];const commands=[];let commandArgs;let command;for(let i=0;i<tokens.length;++i){commandArgs=typeMap[tokens[i]];if(commandArgs){command={type:tokens[i]};for(let a=0;a<commandArgs.length;++a){command[commandArgs[a]]=+tokens[i+a+1];}i+=commandArgs.length;commands.push(command);}}return commands;}}\";\n  _f.__workletHash = 16652980741940;\n  _f.__location = \"D:\\\\Personal\\\\00 Dossair\\\\CryptoTrackerFinal\\\\node_modules\\\\react-native-wagmi-charts\\\\lib\\\\module\\\\charts\\\\line\\\\utils\\\\interpolatePath.js (398:7)\";\n\n  global.__reanimatedWorkletInit(_f);\n\n  return _f;\n}();\nexport var interpolatePathCommands = function () {\n  var _f = function _f(aCommandsInput, bCommandsInput, excludeSegment) {\n    var aCommands = aCommandsInput == null ? [] : aCommandsInput.slice();\n    var bCommands = bCommandsInput == null ? [] : bCommandsInput.slice();\n\n    if (!aCommands.length && !bCommands.length) {\n      return function () {\n        var _f = function _f() {\n          return [];\n        };\n\n        _f._closure = {};\n        _f.asString = \"function nullInterpolator(){return[];}\";\n        _f.__workletHash = 17283802365201;\n        _f.__location = \"D:\\\\Personal\\\\00 Dossair\\\\CryptoTrackerFinal\\\\node_modules\\\\react-native-wagmi-charts\\\\lib\\\\module\\\\charts\\\\line\\\\utils\\\\interpolatePath.js (452:11)\";\n\n        global.__reanimatedWorkletInit(_f);\n\n        return _f;\n      }();\n    }\n\n    var addZ = (aCommands.length === 0 || aCommands[aCommands.length - 1].type === 'Z') && (bCommands.length === 0 || bCommands[bCommands.length - 1].type === 'Z');\n\n    if (aCommands.length > 0 && aCommands[aCommands.length - 1].type === 'Z') {\n      aCommands.pop();\n    }\n\n    if (bCommands.length > 0 && bCommands[bCommands.length - 1].type === 'Z') {\n      bCommands.pop();\n    }\n\n    if (!aCommands.length) {\n      aCommands.push(bCommands[0]);\n    } else if (!bCommands.length) {\n      bCommands.push(aCommands[0]);\n    }\n\n    var numPointsToExtend = Math.abs(bCommands.length - aCommands.length);\n\n    if (numPointsToExtend !== 0) {\n      if (bCommands.length > aCommands.length) {\n        aCommands = extend(aCommands, bCommands, excludeSegment);\n      } else if (bCommands.length < aCommands.length) {\n        bCommands = extend(bCommands, aCommands, excludeSegment);\n      }\n    }\n\n    aCommands = aCommands.map(function (aCommand, i) {\n      return convertToSameType(aCommand, bCommands[i]);\n    });\n    var interpolatedCommands = aCommands.map(function (aCommand) {\n      return aCommand;\n    });\n\n    if (addZ) {\n      interpolatedCommands.push({\n        type: 'Z'\n      });\n      aCommands.push({\n        type: 'Z'\n      });\n    }\n\n    return function () {\n      var _f = function _f(t) {\n        if (t === 1) {\n          return bCommandsInput == null ? [] : bCommandsInput;\n        }\n\n        if (t === 0) {\n          return aCommands;\n        }\n\n        for (var i = 0; i < interpolatedCommands.length; ++i) {\n          var aCommand = aCommands[i];\n          var bCommand = bCommands[i];\n          var interpolatedCommand = interpolatedCommands[i];\n\n          for (var j = 0; j < typeMap[interpolatedCommand.type].length; j++) {\n            var arg = typeMap[interpolatedCommand.type][j];\n            interpolatedCommand[arg] = (1 - t) * aCommand[arg] + t * bCommand[arg];\n\n            if (arg === 'largeArcFlag' || arg === 'sweepFlag') {\n              interpolatedCommand[arg] = Math.round(interpolatedCommand[arg]);\n            }\n          }\n        }\n\n        return interpolatedCommands;\n      };\n\n      _f._closure = {\n        bCommandsInput: bCommandsInput,\n        aCommands: aCommands,\n        interpolatedCommands: interpolatedCommands,\n        bCommands: bCommands,\n        typeMap: typeMap\n      };\n      _f.asString = \"function pathCommandInterpolator(t){const{bCommandsInput,aCommands,interpolatedCommands,bCommands,typeMap}=jsThis._closure;{if(t===1){return bCommandsInput==null?[]:bCommandsInput;}if(t===0){return aCommands;}for(let i=0;i<interpolatedCommands.length;++i){const aCommand=aCommands[i];const bCommand=bCommands[i];const interpolatedCommand=interpolatedCommands[i];for(let j=0;j<typeMap[interpolatedCommand.type].length;j++){const arg=typeMap[interpolatedCommand.type][j];interpolatedCommand[arg]=(1-t)*aCommand[arg]+t*bCommand[arg];if(arg==='largeArcFlag'||arg==='sweepFlag'){interpolatedCommand[arg]=Math.round(interpolatedCommand[arg]);}}}return interpolatedCommands;}}\";\n      _f.__workletHash = 7138204882362;\n      _f.__location = \"D:\\\\Personal\\\\00 Dossair\\\\CryptoTrackerFinal\\\\node_modules\\\\react-native-wagmi-charts\\\\lib\\\\module\\\\charts\\\\line\\\\utils\\\\interpolatePath.js (506:9)\";\n\n      global.__reanimatedWorkletInit(_f);\n\n      return _f;\n    }();\n  };\n\n  _f._closure = {\n    extend: extend,\n    convertToSameType: convertToSameType,\n    typeMap: typeMap\n  };\n  _f.asString = \"function interpolatePathCommands(aCommandsInput,bCommandsInput,excludeSegment){const{extend,convertToSameType,typeMap}=jsThis._closure;{let aCommands=aCommandsInput==null?[]:aCommandsInput.slice();let bCommands=bCommandsInput==null?[]:bCommandsInput.slice();if(!aCommands.length&&!bCommands.length){return function nullInterpolator(){'worklet';return[];};}const addZ=(aCommands.length===0||aCommands[aCommands.length-1].type==='Z')&&(bCommands.length===0||bCommands[bCommands.length-1].type==='Z');if(aCommands.length>0&&aCommands[aCommands.length-1].type==='Z'){aCommands.pop();}if(bCommands.length>0&&bCommands[bCommands.length-1].type==='Z'){bCommands.pop();}if(!aCommands.length){aCommands.push(bCommands[0]);}else if(!bCommands.length){bCommands.push(aCommands[0]);}const numPointsToExtend=Math.abs(bCommands.length-aCommands.length);if(numPointsToExtend!==0){if(bCommands.length>aCommands.length){aCommands=extend(aCommands,bCommands,excludeSegment);}else if(bCommands.length<aCommands.length){bCommands=extend(bCommands,aCommands,excludeSegment);}}aCommands=aCommands.map(function(aCommand,i){return convertToSameType(aCommand,bCommands[i]);});const interpolatedCommands=aCommands.map(function(aCommand){return aCommand;});if(addZ){interpolatedCommands.push({type:'Z'});aCommands.push({type:'Z'});}return function pathCommandInterpolator(t){'worklet';if(t===1){return bCommandsInput==null?[]:bCommandsInput;}if(t===0){return aCommands;}for(let i=0;i<interpolatedCommands.length;++i){const aCommand=aCommands[i];const bCommand=bCommands[i];const interpolatedCommand=interpolatedCommands[i];for(let j=0;j<typeMap[interpolatedCommand.type].length;j++){const arg=typeMap[interpolatedCommand.type][j];interpolatedCommand[arg]=(1-t)*aCommand[arg]+t*bCommand[arg];if(arg==='largeArcFlag'||arg==='sweepFlag'){interpolatedCommand[arg]=Math.round(interpolatedCommand[arg]);}}}return interpolatedCommands;};}}\";\n  _f.__workletHash = 14772747910830;\n  _f.__location = \"D:\\\\Personal\\\\00 Dossair\\\\CryptoTrackerFinal\\\\node_modules\\\\react-native-wagmi-charts\\\\lib\\\\module\\\\charts\\\\line\\\\utils\\\\interpolatePath.js (445:7)\";\n\n  global.__reanimatedWorkletInit(_f);\n\n  return _f;\n}();\nexport var interpolatePath = function () {\n  var _f = function _f(a, b, excludeSegment) {\n    var aCommands = pathCommandsFromString(a);\n    var bCommands = pathCommandsFromString(b);\n\n    if (!aCommands.length && !bCommands.length) {\n      return function () {\n        var _f = function _f() {\n          return '';\n        };\n\n        _f._closure = {};\n        _f.asString = \"function nullInterpolator(){return'';}\";\n        _f.__workletHash = 4411375907159;\n        _f.__location = \"D:\\\\Personal\\\\00 Dossair\\\\CryptoTrackerFinal\\\\node_modules\\\\react-native-wagmi-charts\\\\lib\\\\module\\\\charts\\\\line\\\\utils\\\\interpolatePath.js (559:11)\";\n\n        global.__reanimatedWorkletInit(_f);\n\n        return _f;\n      }();\n    }\n\n    var commandInterpolator = interpolatePathCommands(aCommands, bCommands, excludeSegment);\n    return function () {\n      var _f = function _f(t) {\n        if (t === 1) {\n          return b == null ? '' : b;\n        }\n\n        var interpolatedCommands = commandInterpolator(t);\n        var interpolatedString = '';\n\n        for (var i = 0; i < interpolatedCommands.length; i++) {\n          var interpolatedCommand = interpolatedCommands[i];\n          interpolatedString += commandToString(interpolatedCommand);\n        }\n\n        return interpolatedString;\n      };\n\n      _f._closure = {\n        b: b,\n        commandInterpolator: commandInterpolator,\n        commandToString: commandToString\n      };\n      _f.asString = \"function pathStringInterpolator(t){const{b,commandInterpolator,commandToString}=jsThis._closure;{if(t===1){return b==null?'':b;}const interpolatedCommands=commandInterpolator(t);let interpolatedString='';for(let i=0;i<interpolatedCommands.length;i++){const interpolatedCommand=interpolatedCommands[i];interpolatedString+=commandToString(interpolatedCommand);}return interpolatedString;}}\";\n      _f.__workletHash = 1926708691846;\n      _f.__location = \"D:\\\\Personal\\\\00 Dossair\\\\CryptoTrackerFinal\\\\node_modules\\\\react-native-wagmi-charts\\\\lib\\\\module\\\\charts\\\\line\\\\utils\\\\interpolatePath.js (567:9)\";\n\n      global.__reanimatedWorkletInit(_f);\n\n      return _f;\n    }();\n  };\n\n  _f._closure = {\n    pathCommandsFromString: pathCommandsFromString,\n    interpolatePathCommands: interpolatePathCommands,\n    commandToString: commandToString\n  };\n  _f.asString = \"function interpolatePath(a,b,excludeSegment){const{pathCommandsFromString,interpolatePathCommands,commandToString}=jsThis._closure;{let aCommands=pathCommandsFromString(a);let bCommands=pathCommandsFromString(b);if(!aCommands.length&&!bCommands.length){return function nullInterpolator(){'worklet';return'';};}const commandInterpolator=interpolatePathCommands(aCommands,bCommands,excludeSegment);return function pathStringInterpolator(t){'worklet';if(t===1){return b==null?'':b;}const interpolatedCommands=commandInterpolator(t);let interpolatedString='';for(let i=0;i<interpolatedCommands.length;i++){const interpolatedCommand=interpolatedCommands[i];interpolatedString+=commandToString(interpolatedCommand);}return interpolatedString;};}}\";\n  _f.__workletHash = 3176316250088;\n  _f.__location = \"D:\\\\Personal\\\\00 Dossair\\\\CryptoTrackerFinal\\\\node_modules\\\\react-native-wagmi-charts\\\\lib\\\\module\\\\charts\\\\line\\\\utils\\\\interpolatePath.js (552:7)\";\n\n  global.__reanimatedWorkletInit(_f);\n\n  return _f;\n}();","map":{"version":3,"sources":["interpolatePath.ts"],"names":["left","right","points","newPoints","Array","i","t","decasteljauRecurse","command","segmentCount","segments","remainingCurve","tIncrement","tRelative","split","decasteljau","commandStart","commandEnd","splitCurveAsPoints","typeMap","M","L","H","V","C","S","Q","T","A","Z","Object","key","array","type","p","conversionMap","x1","y1","x2","y2","readFromBKeys","aCommand","bCommand","aConverted","bKey","bValue","aValue","splitCurve","copyCommand","arrayOfLength","numSegmentsToExtend","commandsToExtend","numReferenceSegments","referenceCommands","segmentRatio","countPointsPerSegment","insertIndex","Math","excludeSegment","addToPriorSegment","accum","extended","lastCommandCopies","d","splitSegment","tokens","commands","commandArgs","a","aCommands","aCommandsInput","bCommands","bCommandsInput","addZ","numPointsToExtend","extend","convertToSameType","interpolatedCommands","interpolatedCommand","j","arg","pathCommandsFromString","commandInterpolator","interpolatePathCommands","b","interpolatedString","commandToString"],"mappings":"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","sourcesContent":["// @ts-nocheck\n\n/**\n * Reanimated compatible fork of https://github.com/pbeshai/d3-interpolate-path\n */\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////\n\n/**\n * de Casteljau's algorithm for drawing and splitting bezier curves.\n * Inspired by https://pomax.github.io/bezierinfo/\n *\n * @param {Number[][]} points Array of [x,y] points: [start, control1, control2, ..., end]\n *   The original segment to split.\n * @param {Number} t Where to split the curve (value between [0, 1])\n * @return {Object} An object { left, right } where left is the segment from 0..t and\n *   right is the segment from t..1.\n */\nfunction decasteljau(points, t) {\n  'worklet';\n\n  const left = [];\n  const right = [];\n\n  function decasteljauRecurse(points, t) {\n    'worklet';\n\n    if (points.length === 1) {\n      left.push(points[0]);\n      right.push(points[0]);\n    } else {\n      const newPoints = Array(points.length - 1);\n\n      for (let i = 0; i < newPoints.length; i++) {\n        if (i === 0) {\n          left.push(points[0]);\n        }\n        if (i === newPoints.length - 1) {\n          right.push(points[i + 1]);\n        }\n\n        newPoints[i] = [\n          (1 - t) * points[i][0] + t * points[i + 1][0],\n          (1 - t) * points[i][1] + t * points[i + 1][1],\n        ];\n      }\n\n      decasteljauRecurse(newPoints, t);\n    }\n  }\n\n  if (points.length) {\n    decasteljauRecurse(points, t);\n  }\n\n  return { left, right: right.reverse() };\n}\n\n/**\n * Convert segments represented as points back into a command object\n *\n * @param {Number[][]} points Array of [x,y] points: [start, control1, control2, ..., end]\n *   Represents a segment\n * @return {Object} A command object representing the segment.\n */\nfunction pointsToCommand(points) {\n  'worklet';\n\n  const command = {};\n\n  if (points.length === 4) {\n    command.x2 = points[2][0];\n    command.y2 = points[2][1];\n  }\n  if (points.length >= 3) {\n    command.x1 = points[1][0];\n    command.y1 = points[1][1];\n  }\n\n  command.x = points[points.length - 1][0];\n  command.y = points[points.length - 1][1];\n\n  if (points.length === 4) {\n    // start, control1, control2, end\n    command.type = 'C';\n  } else if (points.length === 3) {\n    // start, control, end\n    command.type = 'Q';\n  } else {\n    // start, end\n    command.type = 'L';\n  }\n\n  return command;\n}\n\n/**\n * Runs de Casteljau's algorithm enough times to produce the desired number of segments.\n *\n * @param {Number[][]} points Array of [x,y] points for de Casteljau (the initial segment to split)\n * @param {Number} segmentCount Number of segments to split the original into\n * @return {Number[][][]} Array of segments\n */\nfunction splitCurveAsPoints(points, segmentCount) {\n  'worklet';\n\n  segmentCount = segmentCount || 2;\n\n  const segments = [];\n  let remainingCurve = points;\n  const tIncrement = 1 / segmentCount;\n\n  // x-----x-----x-----x\n  // t=  0.33   0.66   1\n  // x-----o-----------x\n  // r=  0.33\n  //       x-----o-----x\n  // r=         0.5  (0.33 / (1 - 0.33))  === tIncrement / (1 - (tIncrement * (i - 1))\n\n  // x-----x-----x-----x----x\n  // t=  0.25   0.5   0.75  1\n  // x-----o----------------x\n  // r=  0.25\n  //       x-----o----------x\n  // r=         0.33  (0.25 / (1 - 0.25))\n  //             x-----o----x\n  // r=         0.5  (0.25 / (1 - 0.5))\n\n  for (let i = 0; i < segmentCount - 1; i++) {\n    const tRelative = tIncrement / (1 - tIncrement * i);\n    const split = decasteljau(remainingCurve, tRelative);\n    segments.push(split.left);\n    remainingCurve = split.right;\n  }\n\n  // last segment is just to the end from the last point\n  segments.push(remainingCurve);\n\n  return segments;\n}\n\n/**\n * Convert command objects to arrays of points, run de Casteljau's algorithm on it\n * to split into to the desired number of segments.\n *\n * @param {Object} commandStart The start command object\n * @param {Object} commandEnd The end command object\n * @param {Number} segmentCount The number of segments to create\n * @return {Object[]} An array of commands representing the segments in sequence\n */\nexport function splitCurve(commandStart, commandEnd, segmentCount) {\n  'worklet';\n\n  const points = [[commandStart.x, commandStart.y]];\n  if (commandEnd.x1 != null) {\n    points.push([commandEnd.x1, commandEnd.y1]);\n  }\n  if (commandEnd.x2 != null) {\n    points.push([commandEnd.x2, commandEnd.y2]);\n  }\n  points.push([commandEnd.x, commandEnd.y]);\n\n  return splitCurveAsPoints(points, segmentCount).map(pointsToCommand);\n}\n\n/**\n * List of params for each command type in a path `d` attribute\n */\nconst typeMap = {\n  M: ['x', 'y'],\n  L: ['x', 'y'],\n  H: ['x'],\n  V: ['y'],\n  C: ['x1', 'y1', 'x2', 'y2', 'x', 'y'],\n  S: ['x2', 'y2', 'x', 'y'],\n  Q: ['x1', 'y1', 'x', 'y'],\n  T: ['x', 'y'],\n  A: ['rx', 'ry', 'xAxisRotation', 'largeArcFlag', 'sweepFlag', 'x', 'y'],\n  Z: [],\n};\n\n// Add lower case entries too matching uppercase (e.g. 'm' == 'M')\nObject.keys(typeMap).forEach((key) => {\n  typeMap[key.toLowerCase()] = typeMap[key];\n});\n\nfunction arrayOfLength(length, value) {\n  'worklet';\n\n  const array = Array(length);\n  for (let i = 0; i < length; i++) {\n    array[i] = value;\n  }\n\n  return array;\n}\n\n/**\n * Converts a command object to a string to be used in a `d` attribute\n * @param {Object} command A command object\n * @return {String} The string for the `d` attribute\n */\nfunction commandToString(command) {\n  'worklet';\n\n  return `${command.type}${typeMap[command.type]\n    .map((p) => command[p])\n    .join(',')}`;\n}\n\n/**\n * Converts command A to have the same type as command B.\n *\n * e.g., L0,5 -> C0,5,0,5,0,5\n *\n * Uses these rules:\n * x1 <- x\n * x2 <- x\n * y1 <- y\n * y2 <- y\n * rx <- 0\n * ry <- 0\n * xAxisRotation <- read from B\n * largeArcFlag <- read from B\n * sweepflag <- read from B\n *\n * @param {Object} aCommand Command object from path `d` attribute\n * @param {Object} bCommand Command object from path `d` attribute to match against\n * @return {Object} aCommand converted to type of bCommand\n */\nfunction convertToSameType(aCommand, bCommand) {\n  'worklet';\n\n  const conversionMap = {\n    x1: 'x',\n    y1: 'y',\n    x2: 'x',\n    y2: 'y',\n  };\n\n  const readFromBKeys = ['xAxisRotation', 'largeArcFlag', 'sweepFlag'];\n\n  // convert (but ignore M types)\n  if (aCommand.type !== bCommand.type && bCommand.type.toUpperCase() !== 'M') {\n    const aConverted = {};\n    Object.keys(bCommand).forEach((bKey) => {\n      const bValue = bCommand[bKey];\n      // first read from the A command\n      let aValue = aCommand[bKey];\n\n      // if it is one of these values, read from B no matter what\n      if (aValue === undefined) {\n        if (readFromBKeys.includes(bKey)) {\n          aValue = bValue;\n        } else {\n          // if it wasn't in the A command, see if an equivalent was\n          if (aValue === undefined && conversionMap[bKey]) {\n            aValue = aCommand[conversionMap[bKey]];\n          }\n\n          // if it doesn't have a converted value, use 0\n          if (aValue === undefined) {\n            aValue = 0;\n          }\n        }\n      }\n\n      aConverted[bKey] = aValue;\n    });\n\n    // update the type to match B\n    aConverted.type = bCommand.type;\n    aCommand = aConverted;\n  }\n\n  return aCommand;\n}\n\n/**\n * Interpolate between command objects commandStart and commandEnd segmentCount times.\n * If the types are L, Q, or C then the curves are split as per de Casteljau's algorithm.\n * Otherwise we just copy commandStart segmentCount - 1 times, finally ending with commandEnd.\n *\n * @param {Object} commandStart Command object at the beginning of the segment\n * @param {Object} commandEnd Command object at the end of the segment\n * @param {Number} segmentCount The number of segments to split this into. If only 1\n *   Then [commandEnd] is returned.\n * @return {Object[]} Array of ~segmentCount command objects between commandStart and\n *   commandEnd. (Can be segmentCount+1 objects if commandStart is type M).\n */\nfunction splitSegment(commandStart, commandEnd, segmentCount) {\n  'worklet';\n\n  let segments = [];\n\n  // line, quadratic bezier, or cubic bezier\n  if (\n    commandEnd.type === 'L' ||\n    commandEnd.type === 'Q' ||\n    commandEnd.type === 'C'\n  ) {\n    segments = segments.concat(\n      splitCurve(commandStart, commandEnd, segmentCount)\n    );\n\n    // general case - just copy the same point\n  } else {\n    const copyCommand = Object.assign({}, commandStart);\n\n    // convert M to L\n    if (copyCommand.type === 'M') {\n      copyCommand.type = 'L';\n    }\n\n    segments = segments.concat(\n      arrayOfLength(segmentCount - 1).map(() => copyCommand)\n    );\n    segments.push(commandEnd);\n  }\n\n  return segments;\n}\n/**\n * Extends an array of commandsToExtend to the length of the referenceCommands by\n * splitting segments until the number of commands match. Ensures all the actual\n * points of commandsToExtend are in the extended array.\n *\n * @param {Object[]} commandsToExtend The command object array to extend\n * @param {Object[]} referenceCommands The command object array to match in length\n * @param {Function} excludeSegment a function that takes a start command object and\n *   end command object and returns true if the segment should be excluded from splitting.\n * @return {Object[]} The extended commandsToExtend array\n */\nfunction extend(commandsToExtend, referenceCommands, excludeSegment) {\n  'worklet';\n\n  // compute insertion points:\n  // number of segments in the path to extend\n  const numSegmentsToExtend = commandsToExtend.length - 1;\n\n  // number of segments in the reference path.\n  const numReferenceSegments = referenceCommands.length - 1;\n\n  // this value is always between [0, 1].\n  const segmentRatio = numSegmentsToExtend / numReferenceSegments;\n\n  // create a map, mapping segments in referenceCommands to how many points\n  // should be added in that segment (should always be >= 1 since we need each\n  // point itself).\n  // 0 = segment 0-1, 1 = segment 1-2, n-1 = last vertex\n  const countPointsPerSegment = arrayOfLength(numReferenceSegments).reduce(\n    (accum, d, i) => {\n      let insertIndex = Math.floor(segmentRatio * i);\n\n      // handle excluding segments\n      if (\n        excludeSegment &&\n        insertIndex < commandsToExtend.length - 1 &&\n        excludeSegment(\n          commandsToExtend[insertIndex],\n          commandsToExtend[insertIndex + 1]\n        )\n      ) {\n        // set the insertIndex to the segment that this point should be added to:\n\n        // round the insertIndex essentially so we split half and half on\n        // neighbouring segments. hence the segmentRatio * i < 0.5\n        const addToPriorSegment = (segmentRatio * i) % 1 < 0.5;\n\n        // only skip segment if we already have 1 point in it (can't entirely remove a segment)\n        if (accum[insertIndex]) {\n          // TODO - Note this is a naive algorithm that should work for most d3-area use cases\n          // but if two adjacent segments are supposed to be skipped, this will not perform as\n          // expected. Could be updated to search for nearest segment to place the point in, but\n          // will only do that if necessary.\n\n          // add to the prior segment\n          if (addToPriorSegment) {\n            if (insertIndex > 0) {\n              insertIndex -= 1;\n\n              // not possible to add to previous so adding to next\n            } else if (insertIndex < commandsToExtend.length - 1) {\n              insertIndex += 1;\n            }\n            // add to next segment\n          } else if (insertIndex < commandsToExtend.length - 1) {\n            insertIndex += 1;\n\n            // not possible to add to next so adding to previous\n          } else if (insertIndex > 0) {\n            insertIndex -= 1;\n          }\n        }\n      }\n\n      accum[insertIndex] = (accum[insertIndex] || 0) + 1;\n\n      return accum;\n    },\n    []\n  );\n\n  // extend each segment to have the correct number of points for a smooth interpolation\n  const extended = countPointsPerSegment.reduce((extended, segmentCount, i) => {\n    // if last command, just add `segmentCount` number of times\n    if (i === commandsToExtend.length - 1) {\n      const lastCommandCopies = arrayOfLength(\n        segmentCount,\n        Object.assign({}, commandsToExtend[commandsToExtend.length - 1])\n      );\n\n      // convert M to L\n      if (lastCommandCopies[0].type === 'M') {\n        lastCommandCopies.forEach((d) => {\n          d.type = 'L';\n        });\n      }\n      return extended.concat(lastCommandCopies);\n    }\n\n    // otherwise, split the segment segmentCount times.\n    return extended.concat(\n      splitSegment(commandsToExtend[i], commandsToExtend[i + 1], segmentCount)\n    );\n  }, []);\n\n  // add in the very first point since splitSegment only adds in the ones after it\n  extended.unshift(commandsToExtend[0]);\n\n  return extended;\n}\n\n/**\n * Takes a path `d` string and converts it into an array of command\n * objects. Drops the `Z` character.\n *\n * @param {String|null} d A path `d` string\n */\nexport function pathCommandsFromString(d) {\n  'worklet';\n\n  // split into valid tokens\n  const tokens = (d || '').match(/[MLCSTQAHVZmlcstqahv]|-?[\\d.e+-]+/g) || [];\n  const commands = [];\n  let commandArgs;\n  let command;\n\n  // iterate over each token, checking if we are at a new command\n  // by presence in the typeMap\n  for (let i = 0; i < tokens.length; ++i) {\n    commandArgs = typeMap[tokens[i]];\n\n    // new command found:\n    if (commandArgs) {\n      command = {\n        type: tokens[i],\n      };\n\n      // add each of the expected args for this command:\n      for (let a = 0; a < commandArgs.length; ++a) {\n        command[commandArgs[a]] = +tokens[i + a + 1];\n      }\n\n      // need to increment our token index appropriately since\n      // we consumed token args\n      i += commandArgs.length;\n\n      commands.push(command);\n    }\n  }\n  return commands;\n}\n\n/**\n * Interpolate from A to B by extending A and B during interpolation to have\n * the same number of points. This allows for a smooth transition when they\n * have a different number of points.\n *\n * Ignores the `Z` command in paths unless both A and B end with it.\n *\n * This function works directly with arrays of command objects instead of with\n * path `d` strings (see interpolatePath for working with `d` strings).\n *\n * @param {Object[]} aCommandsInput Array of path commands\n * @param {Object[]} bCommandsInput Array of path commands\n * @param {Function} excludeSegment a function that takes a start command object and\n *   end command object and returns true if the segment should be excluded from splitting.\n * @returns {Function} Interpolation function that maps t ([0, 1]) to an array of path commands.\n */\nexport function interpolatePathCommands(\n  aCommandsInput,\n  bCommandsInput,\n  excludeSegment\n) {\n  'worklet';\n\n  // make a copy so we don't mess with the input arrays\n  let aCommands = aCommandsInput == null ? [] : aCommandsInput.slice();\n  let bCommands = bCommandsInput == null ? [] : bCommandsInput.slice();\n\n  // both input sets are empty, so we don't interpolate\n  if (!aCommands.length && !bCommands.length) {\n    return function nullInterpolator() {\n      'worklet';\n\n      return [];\n    };\n  }\n\n  // do we add Z during interpolation? yes if both have it. (we'd expect both to have it or not)\n  const addZ =\n    (aCommands.length === 0 || aCommands[aCommands.length - 1].type === 'Z') &&\n    (bCommands.length === 0 || bCommands[bCommands.length - 1].type === 'Z');\n\n  // we temporarily remove Z\n  if (aCommands.length > 0 && aCommands[aCommands.length - 1].type === 'Z') {\n    aCommands.pop();\n  }\n  if (bCommands.length > 0 && bCommands[bCommands.length - 1].type === 'Z') {\n    bCommands.pop();\n  }\n\n  // if A is empty, treat it as if it used to contain just the first point\n  // of B. This makes it so the line extends out of from that first point.\n  if (!aCommands.length) {\n    aCommands.push(bCommands[0]);\n\n    // otherwise if B is empty, treat it as if it contains the first point\n    // of A. This makes it so the line retracts into the first point.\n  } else if (!bCommands.length) {\n    bCommands.push(aCommands[0]);\n  }\n\n  // extend to match equal size\n  const numPointsToExtend = Math.abs(bCommands.length - aCommands.length);\n\n  if (numPointsToExtend !== 0) {\n    // B has more points than A, so add points to A before interpolating\n    if (bCommands.length > aCommands.length) {\n      aCommands = extend(aCommands, bCommands, excludeSegment);\n\n      // else if A has more points than B, add more points to B\n    } else if (bCommands.length < aCommands.length) {\n      bCommands = extend(bCommands, aCommands, excludeSegment);\n    }\n  }\n\n  // commands have same length now.\n  // convert commands in A to the same type as those in B\n  aCommands = aCommands.map((aCommand, i) =>\n    convertToSameType(aCommand, bCommands[i])\n  );\n\n  // create mutable interpolated command objects\n  const interpolatedCommands = aCommands.map((aCommand) => aCommand);\n\n  if (addZ) {\n    interpolatedCommands.push({ type: 'Z' });\n    aCommands.push({ type: 'Z' }); // required for when returning at t == 0\n  }\n\n  return function pathCommandInterpolator(t) {\n    'worklet';\n\n    // at 1 return the final value without the extensions used during interpolation\n    if (t === 1) {\n      return bCommandsInput == null ? [] : bCommandsInput;\n    }\n\n    // work with aCommands directly since interpolatedCommands are mutated\n    if (t === 0) {\n      return aCommands;\n    }\n\n    // interpolate the commands using the mutable interpolated command objs\n    for (let i = 0; i < interpolatedCommands.length; ++i) {\n      // if (interpolatedCommands[i].type === 'Z') continue;\n\n      const aCommand = aCommands[i];\n      const bCommand = bCommands[i];\n      const interpolatedCommand = interpolatedCommands[i];\n      for (let j = 0; j < typeMap[interpolatedCommand.type].length; j++) {\n        const arg = typeMap[interpolatedCommand.type][j];\n        interpolatedCommand[arg] = (1 - t) * aCommand[arg] + t * bCommand[arg];\n\n        // do not use floats for flags (#27), round to integer\n        if (arg === 'largeArcFlag' || arg === 'sweepFlag') {\n          interpolatedCommand[arg] = Math.round(interpolatedCommand[arg]);\n        }\n      }\n    }\n\n    return interpolatedCommands;\n  };\n}\n\n/**\n * Interpolate from A to B by extending A and B during interpolation to have\n * the same number of points. This allows for a smooth transition when they\n * have a different number of points.\n *\n * Ignores the `Z` character in paths unless both A and B end with it.\n *\n * @param {String} a The `d` attribute for a path\n * @param {String} b The `d` attribute for a path\n * @param {Function} excludeSegment a function that takes a start command object and\n *   end command object and returns true if the segment should be excluded from splitting.\n * @returns {Function} Interpolation function that maps t ([0, 1]) to a path `d` string.\n */\nexport function interpolatePath(a, b, excludeSegment) {\n  'worklet';\n\n  let aCommands = pathCommandsFromString(a);\n  let bCommands = pathCommandsFromString(b);\n\n  if (!aCommands.length && !bCommands.length) {\n    return function nullInterpolator() {\n      'worklet';\n\n      return '';\n    };\n  }\n\n  const commandInterpolator = interpolatePathCommands(\n    aCommands,\n    bCommands,\n    excludeSegment\n  );\n\n  return function pathStringInterpolator(t) {\n    'worklet';\n\n    // at 1 return the final value without the extensions used during interpolation\n    if (t === 1) {\n      return b == null ? '' : b;\n    }\n\n    const interpolatedCommands = commandInterpolator(t);\n\n    // convert to a string (fastest concat: https://jsperf.com/join-concat/150)\n    let interpolatedString = '';\n    for (let i = 0; i < interpolatedCommands.length; i++) {\n      const interpolatedCommand = interpolatedCommands[i];\n      interpolatedString += commandToString(interpolatedCommand);\n    }\n\n    return interpolatedString;\n  };\n}\n"]},"metadata":{},"sourceType":"module"}