{"ast":null,"code":"function _extends() {\n  _extends = Object.assign || function (target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i];\n\n      for (var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n          target[key] = source[key];\n        }\n      }\n    }\n\n    return target;\n  };\n\n  return _extends.apply(this, arguments);\n}\n\nimport React from 'react';\nimport Animated, { useAnimatedProps, useDerivedValue, withTiming } from 'react-native-reanimated';\nimport { Line as SVGLine } from 'react-native-svg';\nimport { getYForX, parse } from 'react-native-redash';\nimport { LineChartDimensionsContext } from \"./Chart\";\nimport { useLineChart } from \"./useLineChart\";\nvar AnimatedLine = Animated.createAnimatedComponent(SVGLine);\nLineChartHorizontalLine.displayName = 'LineChartHorizontalLine';\nexport function LineChartHorizontalLine(_ref) {\n  var _ref$color = _ref.color,\n      color = _ref$color === void 0 ? 'gray' : _ref$color,\n      _ref$lineProps = _ref.lineProps,\n      lineProps = _ref$lineProps === void 0 ? {} : _ref$lineProps,\n      _ref$at = _ref.at,\n      at = _ref$at === void 0 ? {\n    index: 0\n  } : _ref$at,\n      _ref$offsetY = _ref.offsetY,\n      offsetY = _ref$offsetY === void 0 ? 0 : _ref$offsetY;\n\n  var _React$useContext = React.useContext(LineChartDimensionsContext),\n      width = _React$useContext.width,\n      path = _React$useContext.path,\n      height = _React$useContext.height,\n      gutter = _React$useContext.gutter;\n\n  var _useLineChart = useLineChart(),\n      data = _useLineChart.data,\n      yDomain = _useLineChart.yDomain;\n\n  var parsedPath = React.useMemo(function () {\n    return parse(path);\n  }, [path]);\n  var pointWidth = React.useMemo(function () {\n    return width / data.length;\n  }, [data.length, width]);\n  var y = useDerivedValue(function () {\n    var _f = function _f() {\n      if (typeof at === 'number' || at.index != null) {\n        var index = typeof at === 'number' ? at : at.index;\n        var yForX = getYForX(parsedPath, pointWidth * index) || 0;\n        return withTiming(yForX + offsetY);\n      }\n\n      var offsetTop = yDomain.max - at.value;\n      var percentageOffsetTop = offsetTop / (yDomain.max - yDomain.min);\n      var heightBetweenGutters = height - gutter * 2;\n      var offsetTopPixels = gutter + percentageOffsetTop * heightBetweenGutters;\n      return withTiming(offsetTopPixels + offsetY);\n    };\n\n    _f._closure = {\n      at: at,\n      getYForX: getYForX,\n      parsedPath: parsedPath,\n      pointWidth: pointWidth,\n      withTiming: withTiming,\n      offsetY: offsetY,\n      yDomain: {\n        max: yDomain.max,\n        min: yDomain.min\n      },\n      height: height,\n      gutter: gutter\n    };\n    _f.asString = \"function _f(){const{at,getYForX,parsedPath,pointWidth,withTiming,offsetY,yDomain,height,gutter}=jsThis._closure;{if(typeof at==='number'||at.index!=null){const index=typeof at==='number'?at:at.index;const yForX=getYForX(parsedPath,pointWidth*index)||0;return withTiming(yForX+offsetY);}const offsetTop=yDomain.max-at.value;const percentageOffsetTop=offsetTop/(yDomain.max-yDomain.min);const heightBetweenGutters=height-gutter*2;const offsetTopPixels=gutter+percentageOffsetTop*heightBetweenGutters;return withTiming(offsetTopPixels+offsetY);}}\";\n    _f.__workletHash = 5044889632983;\n    _f.__location = \"D:\\\\Personal\\\\00 Dossair\\\\CryptoTrackerFinal\\\\node_modules\\\\react-native-wagmi-charts\\\\lib\\\\module\\\\charts\\\\line\\\\HorizontalLine.js (31:28)\";\n\n    global.__reanimatedWorkletInit(_f);\n\n    return _f;\n  }());\n  var lineAnimatedProps = useAnimatedProps(function () {\n    var _f = function _f() {\n      return {\n        x1: 0,\n        x2: width,\n        y1: y.value,\n        y2: y.value\n      };\n    };\n\n    _f._closure = {\n      width: width,\n      y: y\n    };\n    _f.asString = \"function _f(){const{width,y}=jsThis._closure;{return{x1:0,x2:width,y1:y.value,y2:y.value};}}\";\n    _f.__workletHash = 6503751189657;\n    _f.__location = \"D:\\\\Personal\\\\00 Dossair\\\\CryptoTrackerFinal\\\\node_modules\\\\react-native-wagmi-charts\\\\lib\\\\module\\\\charts\\\\line\\\\HorizontalLine.js (54:45)\";\n\n    global.__reanimatedWorkletInit(_f);\n\n    return _f;\n  }());\n  return React.createElement(AnimatedLine, _extends({\n    animatedProps: lineAnimatedProps,\n    strokeWidth: 2,\n    stroke: color,\n    strokeDasharray: \"3 3\"\n  }, lineProps));\n}","map":{"version":3,"sources":["HorizontalLine.tsx"],"names":["Line","SVGLine","AnimatedLine","Animated","LineChartHorizontalLine","color","lineProps","at","index","offsetY","gutter","React","yDomain","useLineChart","parsedPath","parse","pointWidth","width","data","y","useDerivedValue","yForX","getYForX","withTiming","offsetTop","percentageOffsetTop","heightBetweenGutters","height","offsetTopPixels","lineAnimatedProps","useAnimatedProps","x1","x2","y1","y2","value"],"mappings":"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","sourcesContent":["import React from 'react';\nimport Animated, {\n  useAnimatedProps,\n  useDerivedValue,\n  withTiming,\n} from 'react-native-reanimated';\nimport { Line as SVGLine, LineProps } from 'react-native-svg';\nimport { getYForX, parse } from 'react-native-redash';\n\nimport { LineChartDimensionsContext } from './Chart';\nimport { useLineChart } from './useLineChart';\n\nconst AnimatedLine = Animated.createAnimatedComponent(SVGLine);\n\ntype HorizontalLineProps = {\n  color?: string;\n  lineProps?: Partial<LineProps>;\n  offsetY?: number;\n  /**\n   * (Optional) A pixel value to nudge the line up or down.\n   *\n   * This may be useful to customize the line's position based on the thickness of your cursor or chart path.\n   *\n   * ```tsx\n   * <LineChart.HorizontalLine\n   *   at={{ index: 3 }}\n   * />\n   *\n   * // or\n   *\n   * <LineChart.HorizontalLine\n   *   at={{ value: 320.32}}\n   * />\n   * ```\n   */\n  at?:\n    | {\n        index: number;\n        value?: never;\n      }\n    | {\n        index?: never;\n        value: number;\n      }\n    | number;\n};\n\nLineChartHorizontalLine.displayName = 'LineChartHorizontalLine';\n\nexport function LineChartHorizontalLine({\n  color = 'gray',\n  lineProps = {},\n  at = { index: 0 },\n  offsetY = 0,\n}: HorizontalLineProps) {\n  const { width, path, height, gutter } = React.useContext(\n    LineChartDimensionsContext\n  );\n  const { data, yDomain } = useLineChart();\n\n  const parsedPath = React.useMemo(() => parse(path), [path]);\n  const pointWidth = React.useMemo(\n    () => width / data.length,\n    [data.length, width]\n  );\n\n  const y = useDerivedValue(() => {\n    if (typeof at === 'number' || at.index != null) {\n      const index = typeof at === 'number' ? at : at.index;\n      const yForX = getYForX(parsedPath!, pointWidth * index) || 0;\n      return withTiming(yForX + offsetY);\n    }\n    /**\n     * <gutter>\n     * | ---------- | <- yDomain.max  |\n     * |            |                 | offsetTop\n     * |            | <- value        |\n     * |            |\n     * |            | <- yDomain.min\n     * <gutter>\n     */\n\n    const offsetTop = yDomain.max - at.value;\n    const percentageOffsetTop = offsetTop / (yDomain.max - yDomain.min);\n\n    const heightBetweenGutters = height - gutter * 2;\n\n    const offsetTopPixels = gutter + percentageOffsetTop * heightBetweenGutters;\n\n    return withTiming(offsetTopPixels + offsetY);\n  });\n\n  const lineAnimatedProps = useAnimatedProps(() => ({\n    x1: 0,\n    x2: width,\n    y1: y.value,\n    y2: y.value,\n  }));\n\n  return (\n    <AnimatedLine\n      animatedProps={lineAnimatedProps}\n      strokeWidth={2}\n      stroke={color}\n      strokeDasharray=\"3 3\"\n      {...lineProps}\n    />\n  );\n}\n"]},"metadata":{},"sourceType":"module"}