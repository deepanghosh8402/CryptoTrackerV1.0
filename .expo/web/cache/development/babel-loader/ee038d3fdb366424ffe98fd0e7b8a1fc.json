{"ast":null,"code":"import _objectWithoutProperties from \"@babel/runtime/helpers/objectWithoutProperties\";\nvar _excluded = [\"children\", \"xGutter\", \"yGutter\", \"cursorGutter\", \"position\", \"textProps\", \"textStyle\"];\n\nfunction _extends() {\n  _extends = Object.assign || function (target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i];\n\n      for (var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n          target[key] = source[key];\n        }\n      }\n    }\n\n    return target;\n  };\n\n  return _extends.apply(this, arguments);\n}\n\nimport * as React from 'react';\nimport Animated, { useAnimatedStyle, useSharedValue } from 'react-native-reanimated';\nimport { LineChartDimensionsContext } from \"./Chart\";\nimport { CursorContext } from \"./Cursor\";\nimport { LineChartPriceText } from \"./PriceText\";\nimport { useLineChart } from \"./useLineChart\";\nLineChartTooltip.displayName = 'LineChartTooltip';\nexport function LineChartTooltip(_ref) {\n  var children = _ref.children,\n      _ref$xGutter = _ref.xGutter,\n      xGutter = _ref$xGutter === void 0 ? 8 : _ref$xGutter,\n      _ref$yGutter = _ref.yGutter,\n      yGutter = _ref$yGutter === void 0 ? 8 : _ref$yGutter,\n      _ref$cursorGutter = _ref.cursorGutter,\n      cursorGutter = _ref$cursorGutter === void 0 ? 48 : _ref$cursorGutter,\n      _ref$position = _ref.position,\n      position = _ref$position === void 0 ? 'top' : _ref$position,\n      textProps = _ref.textProps,\n      textStyle = _ref.textStyle,\n      props = _objectWithoutProperties(_ref, _excluded);\n\n  var _React$useContext = React.useContext(LineChartDimensionsContext),\n      width = _React$useContext.width,\n      height = _React$useContext.height;\n\n  var _React$useContext2 = React.useContext(CursorContext),\n      type = _React$useContext2.type;\n\n  var _useLineChart = useLineChart(),\n      currentX = _useLineChart.currentX,\n      currentY = _useLineChart.currentY,\n      isActive = _useLineChart.isActive;\n\n  var x = useSharedValue(0);\n  var elementWidth = useSharedValue(0);\n  var elementHeight = useSharedValue(0);\n  var handleLayout = React.useCallback(function (event) {\n    x.value = event.nativeEvent.layout.x;\n    elementWidth.value = event.nativeEvent.layout.width;\n    elementHeight.value = event.nativeEvent.layout.height;\n  }, [elementHeight, elementWidth, x]);\n  var animatedCursorStyle = useAnimatedStyle(function () {\n    var _f = function _f() {\n      var translateXOffset = elementWidth.value / 2;\n\n      if (currentX.value < elementWidth.value / 2 + xGutter) {\n        var xOffset = elementWidth.value / 2 + xGutter - currentX.value;\n        translateXOffset = translateXOffset - xOffset;\n      }\n\n      if (currentX.value > width - elementWidth.value / 2 - xGutter) {\n        var _xOffset = currentX.value - (width - elementWidth.value / 2 - xGutter);\n\n        translateXOffset = translateXOffset + _xOffset;\n      }\n\n      var translateYOffset = 0;\n\n      if (position === 'top') {\n        translateYOffset = elementHeight.value / 2 + cursorGutter;\n\n        if (currentY.value - translateYOffset < yGutter) {\n          translateYOffset = currentY.value - yGutter;\n        }\n      } else if (position === 'bottom') {\n        translateYOffset = -(elementHeight.value / 2) - cursorGutter / 2;\n\n        if (currentY.value - translateYOffset + elementHeight.value > height - yGutter) {\n          translateYOffset = currentY.value - (height - yGutter) + elementHeight.value;\n        }\n      }\n\n      return {\n        transform: [{\n          translateX: currentX.value - translateXOffset\n        }, {\n          translateY: type === 'crosshair' ? currentY.value - translateYOffset : position === 'top' ? yGutter : height - elementHeight.value - yGutter\n        }],\n        opacity: isActive.value ? 1 : 0\n      };\n    };\n\n    _f._closure = {\n      elementWidth: elementWidth,\n      currentX: currentX,\n      xGutter: xGutter,\n      width: width,\n      position: position,\n      elementHeight: elementHeight,\n      cursorGutter: cursorGutter,\n      currentY: currentY,\n      yGutter: yGutter,\n      height: height,\n      type: type,\n      isActive: isActive\n    };\n    _f.asString = \"function _f(){const{elementWidth,currentX,xGutter,width,position,elementHeight,cursorGutter,currentY,yGutter,height,type,isActive}=jsThis._closure;{let translateXOffset=elementWidth.value/2;if(currentX.value<elementWidth.value/2+xGutter){const xOffset=elementWidth.value/2+xGutter-currentX.value;translateXOffset=translateXOffset-xOffset;}if(currentX.value>width-elementWidth.value/2-xGutter){const xOffset=currentX.value-(width-elementWidth.value/2-xGutter);translateXOffset=translateXOffset+xOffset;}let translateYOffset=0;if(position==='top'){translateYOffset=elementHeight.value/2+cursorGutter;if(currentY.value-translateYOffset<yGutter){translateYOffset=currentY.value-yGutter;}}else if(position==='bottom'){translateYOffset=-(elementHeight.value/2)-cursorGutter/2;if(currentY.value-translateYOffset+elementHeight.value>height-yGutter){translateYOffset=currentY.value-(height-yGutter)+elementHeight.value;}}return{transform:[{translateX:currentX.value-translateXOffset},{translateY:type==='crosshair'?currentY.value-translateYOffset:position==='top'?yGutter:height-elementHeight.value-yGutter}],opacity:isActive.value?1:0};}}\";\n    _f.__workletHash = 6770530825671;\n    _f.__location = \"D:\\\\Personal\\\\00 Dossair\\\\CryptoTrackerFinal\\\\node_modules\\\\react-native-wagmi-charts\\\\lib\\\\module\\\\charts\\\\line\\\\Tooltip.js (40:47)\";\n    _f.__optimalization = 1;\n\n    global.__reanimatedWorkletInit(_f);\n\n    return _f;\n  }());\n  return React.createElement(Animated.View, _extends({\n    onLayout: handleLayout\n  }, props, {\n    style: [{\n      position: 'absolute',\n      padding: 4,\n      alignSelf: 'flex-start'\n    }, animatedCursorStyle, props.style]\n  }), children || React.createElement(LineChartPriceText, _extends({\n    style: [textStyle]\n  }, textProps)));\n}","map":{"version":3,"sources":["Tooltip.tsx"],"names":["LineChartTooltip","xGutter","yGutter","cursorGutter","position","props","height","React","type","isActive","useLineChart","x","useSharedValue","elementWidth","elementHeight","handleLayout","event","animatedCursorStyle","useAnimatedStyle","translateXOffset","currentX","xOffset","width","translateYOffset","currentY","transform","translateX","translateY","opacity","padding","alignSelf","children"],"mappings":"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","sourcesContent":["import * as React from 'react';\nimport type { ViewProps } from 'react-native';\nimport Animated, {\n  useAnimatedStyle,\n  useSharedValue,\n} from 'react-native-reanimated';\n\nimport { LineChartDimensionsContext } from './Chart';\nimport { CursorContext } from './Cursor';\nimport { LineChartPriceText, LineChartPriceTextProps } from './PriceText';\nimport { useLineChart } from './useLineChart';\n\ntype LineChartTooltipProps = Animated.AnimateProps<ViewProps> & {\n  children?: React.ReactNode;\n  xGutter?: number;\n  yGutter?: number;\n  cursorGutter?: number;\n  position?: 'top' | 'bottom';\n  textProps?: LineChartPriceTextProps;\n  textStyle?: LineChartPriceTextProps['style'];\n};\n\nLineChartTooltip.displayName = 'LineChartTooltip';\n\nexport function LineChartTooltip({\n  children,\n  xGutter = 8,\n  yGutter = 8,\n  cursorGutter = 48,\n  position = 'top',\n  textProps,\n  textStyle,\n  ...props\n}: LineChartTooltipProps) {\n  const { width, height } = React.useContext(LineChartDimensionsContext);\n  const { type } = React.useContext(CursorContext);\n  const { currentX, currentY, isActive } = useLineChart();\n\n  const x = useSharedValue(0);\n  const elementWidth = useSharedValue(0);\n  const elementHeight = useSharedValue(0);\n\n  const handleLayout = React.useCallback(\n    (event) => {\n      x.value = event.nativeEvent.layout.x;\n      elementWidth.value = event.nativeEvent.layout.width;\n      elementHeight.value = event.nativeEvent.layout.height;\n    },\n    [elementHeight, elementWidth, x]\n  );\n\n  const animatedCursorStyle = useAnimatedStyle(() => {\n    let translateXOffset = elementWidth.value / 2;\n    if (currentX.value < elementWidth.value / 2 + xGutter) {\n      const xOffset = elementWidth.value / 2 + xGutter - currentX.value;\n      translateXOffset = translateXOffset - xOffset;\n    }\n    if (currentX.value > width - elementWidth.value / 2 - xGutter) {\n      const xOffset =\n        currentX.value - (width - elementWidth.value / 2 - xGutter);\n      translateXOffset = translateXOffset + xOffset;\n    }\n\n    let translateYOffset = 0;\n    if (position === 'top') {\n      translateYOffset = elementHeight.value / 2 + cursorGutter;\n      if (currentY.value - translateYOffset < yGutter) {\n        translateYOffset = currentY.value - yGutter;\n      }\n    } else if (position === 'bottom') {\n      translateYOffset = -(elementHeight.value / 2) - cursorGutter / 2;\n      if (\n        currentY.value - translateYOffset + elementHeight.value >\n        height - yGutter\n      ) {\n        translateYOffset =\n          currentY.value - (height - yGutter) + elementHeight.value;\n      }\n    }\n\n    return {\n      transform: [\n        { translateX: currentX.value - translateXOffset },\n        {\n          translateY:\n            type === 'crosshair'\n              ? currentY.value - translateYOffset\n              : position === 'top'\n              ? yGutter\n              : height - elementHeight.value - yGutter,\n        },\n      ],\n      opacity: isActive.value ? 1 : 0,\n    };\n  });\n\n  return (\n    <Animated.View\n      onLayout={handleLayout}\n      {...props}\n      style={[\n        {\n          position: 'absolute',\n          padding: 4,\n          alignSelf: 'flex-start',\n        },\n        animatedCursorStyle,\n        props.style,\n      ]}\n    >\n      {children || <LineChartPriceText style={[textStyle]} {...textProps} />}\n    </Animated.View>\n  );\n}\n"]},"metadata":{},"sourceType":"module"}